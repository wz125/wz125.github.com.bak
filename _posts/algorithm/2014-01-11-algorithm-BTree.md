---
layout: post
title: 'algorithm B-Tree struct'
category: algorithm
tags: [algorithm tree]
---

xxxx


B~树/B+树
##
     对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对RBT进行了优化)。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成RBT结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储.... 都不可能在内存中建立查找结构。必须在磁盘中建立好这个结构。那么在这个背景下，RBT还是一种好的选择吗？
     在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。
    B-Tree的操作代价分析：
    (1) 查找代价： B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。
    (2)插入代价： B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。
    (3)删除代价：B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）
        如果在删除操作中，最有相邻兄弟节点都需要访问则最终需要4n-2此访问，其中第二部2(n-1）次，由于第二层只有2个节点，因此少操作一次  4n-2=h+2(h-2)-1+(h-2)+3
   B-Tree效率总结： 由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。



##example

1. 内部节点最多100个子女，叶节点最多15个记录，对于1/2/3/4层B+树，最多和最小存储记录树数？
分析：B+树最多叶子节点同层，根节点最多2颗子树，其余节点子树个数（m/2 , m） ，m=100
内部节点孩子个数[50,100] 叶节点记录数[1,15];
当有一个节点时，只有根节点，没有记录或15条记录；  
当有个节点时时，与跟节点分裂，成为内部节点，

  | 层|最小 | 最大  
  | 1 | 0 | 15  
  | 2 | 16 | (15 \* 100)  
  | 3 | 16\*50 | 15 \* (100 \* 100)  
  | 4 | 16\*50\*50 | 15 \*(100 \*100 \*100)  
  | 5 | 16\*50\*50\*50 | 15 \*(100 \*100 \*100\*100)  
