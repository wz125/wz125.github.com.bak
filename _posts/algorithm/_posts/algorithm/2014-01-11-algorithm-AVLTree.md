---
layout: post
title: 'algorithm AVL Tree struct'
category: algorithm
tags: [algorithm struct]
---



## AVL

平衡二叉查找树 ( Balanced Binary Search Tree ) AVL
    二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。
    既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。
    AVL 的操作代价分析：
    (1) 查找代价： AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
    (2) 插入代价： AVL必须要保证严格平衡(|bf|<=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
    (3) 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)
   AVL 效率总结 :  查找的时间复杂度维持在O(logN)，不会出现最差情况
                            AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。
                            AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。
